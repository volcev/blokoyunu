const express = require('express');
const fs = require('fs');
const cors = require('cors');
const { Connection, PublicKey, Keypair, clusterApiUrl, Transaction, SystemProgram } = require('@solana/web3.js');
const { getOrCreateAssociatedTokenAccount, createTransferInstruction } = require('@solana/spl-token');
const { Program, AnchorProvider, Wallet, BN } = require('@coral-xyz/anchor');
const bcrypt = require('bcrypt');

// Import blockchain writer - DISABLED due to _bn error
// const {
//   updateMinerOnBlockchain,
//   updateThetOnBlockchain,
//   syncAllMinersToBlockchain,
//   syncThetOwnersToBlockchain,
//   isBlockchainEnabled
// } = require('./blockchain_writer');

// Temporary disabled functions
const updateMinerOnBlockchain = () => Promise.resolve(false);
const updateThetOnBlockchain = () => Promise.resolve(false);
const syncAllMinersToBlockchain = () => Promise.resolve(false);
const syncThetOwnersToBlockchain = () => Promise.resolve(false);
const isBlockchainEnabled = () => false;

// Session store (memory-based, cleared on process restart)
const sessions = {};
function generateSessionToken() {
  return Math.random().toString(36).substring(2) + Date.now().toString(36);
}

const app = express();
const PORT = process.env.PORT || 3001;

const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');
const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const THE_TOKEN_MINT = new PublicKey('7gryqXLucgivS9NHgnA22WFZqLG8jU317pBJYeWkGynH');

const secretKey = JSON.parse(fs.readFileSync('./id.json', 'utf8'));
const senderKeypair = Keypair.fromSecretKey(Uint8Array.from(secretKey));

// Blockchain Stats Configuration
const STATS_PROGRAM_ID = '5f6EPwYGs9LqSYoGb9mBfDwPTmfyQMVq9ERrAgpdojCN';
let blockchainStatsEnabled = false;
let gameStatsPDA = null;

// Initialize blockchain stats (safely)
async function initializeBlockchainStats() {
  try {
    console.log('üîó Attempting to initialize blockchain stats connection...');
    
    const programId = new PublicKey(STATS_PROGRAM_ID);
    const [pda] = PublicKey.findProgramAddressSync(
      [Buffer.from("game_stats_v3")], // Updated to match our deployed program
      programId
    );
    gameStatsPDA = pda;
    // blockchainStatsEnabled = true; // Temporarily disabled to show local data
    
    console.log('‚úÖ Blockchain stats initialized successfully');
    console.log('üìç Program ID:', STATS_PROGRAM_ID);
    console.log('üìç Game Stats PDA:', gameStatsPDA.toString());
    
    // Test blockchain connection
    await testBlockchainConnection();
  } catch (error) {
    console.log('‚ùå Blockchain stats initialization failed:', error.message);
    console.log('üîÑ Continuing with local stats fallback...');
    blockchainStatsEnabled = false;
  }
}

// Test blockchain connection
async function testBlockchainConnection() {
  try {
    console.log('üß™ Testing blockchain connection...');
    const accountInfo = await connection.getAccountInfo(gameStatsPDA);
    if (accountInfo) {
      console.log('‚úÖ Blockchain account found, data size:', accountInfo.data.length);
    } else {
      console.log('‚ö†Ô∏è Blockchain account not found (not initialized yet)');
    }
  } catch (error) {
    console.log('‚ùå Blockchain connection test failed:', error.message);
  }
}

// Parse blockchain account data
function parseBlockchainData(data) {
  try {
    console.log('üîç Parsing blockchain data...');
    
    // Skip the 8-byte discriminator that Anchor adds
    let offset = 8;
    
    // Parse basic stats (u64 values are 8 bytes each)
    const totalBlocks = readU64(data, offset);
    offset += 8;
    
    const minedBlocks = readU64(data, offset);
    offset += 8;
    
    const totalMiners = readU32(data, offset);
    offset += 4;
    
    // Parse miners vector
    const minersLength = readU32(data, offset);
    offset += 4;
    
    const miners = [];
    for (let i = 0; i < Math.min(minersLength, 10); i++) {
      try {
        const miner = parseMinerData(data, offset);
        miners.push(miner.data);
        offset = miner.newOffset;
      } catch (error) {
        console.log(`‚ö†Ô∏è Failed to parse miner ${i}:`, error.message);
        break;
      }
    }
    
    // Parse THET owners vector (similar structure)
    let thetOwners = [];
    if (offset < data.length - 20) { // Ensure we have enough data
      try {
        const ownersLength = readU32(data, offset);
        offset += 4;
        
        for (let i = 0; i < Math.min(ownersLength, 10) && offset < data.length - 20; i++) {
          try {
            const owner = parseThetOwnerData(data, offset);
            thetOwners.push(owner.data);
            offset = owner.newOffset;
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to parse THET owner ${i}:`, error.message);
            break;
          }
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Failed to parse THET owners section:', error.message);
      }
    }
    
    // Parse last updated timestamp
    let lastUpdated = Date.now();
    if (offset <= data.length - 8) {
      try {
        lastUpdated = readI64(data, offset) * 1000; // Convert to milliseconds
      } catch (error) {
        console.log('‚ö†Ô∏è Failed to parse last updated timestamp:', error.message);
      }
    }
    
    const result = {
      totalBlocks: Number(totalBlocks),
      minedBlocks: Number(minedBlocks),
      emptyBlocks: Number(totalBlocks - minedBlocks),
      totalMiners,
      topMiners: miners.slice(0, 3), // Top 3 miners
      topThetOwners: thetOwners.slice(0, 3), // Top 3 THET owners
      lastUpdated: new Date(lastUpdated).toISOString(),
      totalBlocksMined: Number(minedBlocks), // Legacy compatibility
      gridExpansions: Math.floor(Number(totalBlocks) / 100) - 1
    };
    
    console.log('‚úÖ Blockchain data parsed successfully:', {
      totalBlocks: result.totalBlocks,
      minedBlocks: result.minedBlocks,
      minersCount: miners.length,
      thetOwnersCount: thetOwners.length
    });
    
    return result;
  } catch (error) {
    console.error('‚ùå Failed to parse blockchain data:', error);
    return null;
  }
}

// Helper functions to read data types
function readU64(buffer, offset) {
  return buffer.readBigUInt64LE(offset);
}

function readU32(buffer, offset) {
  return buffer.readUInt32LE(offset);
}

function readI64(buffer, offset) {
  return buffer.readBigInt64LE(offset);
}

function parseMinerData(data, offset) {
  // Parse string length (4 bytes)
  const nameLength = readU32(data, offset);
  offset += 4;
  
  // Parse string data
  const name = data.subarray(offset, offset + nameLength).toString('utf8');
  offset += nameLength;
  
  // Parse block count (8 bytes)
  const blockCount = readU64(data, offset);
  offset += 8;
  
  // Parse color string length (4 bytes)
  const colorLength = readU32(data, offset);
  offset += 4;
  
  // Parse color string
  const color = data.subarray(offset, offset + colorLength).toString('utf8');
  offset += colorLength;
  
  return {
    data: {
      name,
      blockCount: Number(blockCount),
      color
    },
    newOffset: offset
  };
}

function parseThetOwnerData(data, offset) {
  // Parse string length (4 bytes)
  const nameLength = readU32(data, offset);
  offset += 4;
  
  // Parse string data
  const name = data.subarray(offset, offset + nameLength).toString('utf8');
  offset += nameLength;
  
  // Parse THET earned (8 bytes)
  const thetEarned = readU64(data, offset);
  offset += 8;
  
  // Parse color string length (4 bytes)
  const colorLength = readU32(data, offset);
  offset += 4;
  
  // Parse color string
  const color = data.subarray(offset, offset + colorLength).toString('utf8');
  offset += colorLength;
  
  return {
    data: {
      name,
      thetEarned: Number(thetEarned),
      color
    },
    newOffset: offset
  };
}

// Initialize on startup
initializeBlockchainStats();

// Real blockchain stats functions
async function incrementBlocksMinedOnChain(amount = 1) {
  if (!blockchainStatsEnabled) {
    console.log('‚ö†Ô∏è Blockchain stats disabled, skipping on-chain update');
    return null;
  }
  
  try {
    console.log(`üìä On-chain stats update: +${amount} blocks mined`);
    console.log(`üîó PDA: ${gameStatsPDA.toString()}`);
    console.log(`üéØ Program: ${STATS_PROGRAM_ID}`);
    
    // For now, we'll log the intended transaction
    // Full implementation would require Anchor client setup
    const mockTx = `real_tx_${Date.now()}`;
    console.log(`‚úÖ Would execute transaction: ${mockTx}`);
    
    return mockTx;
  } catch (error) {
    console.error('Failed to update on-chain stats:', error);
    return null;
  }
}



async function getOnChainStats(username = null) {
  if (!blockchainStatsEnabled) {
    console.log('‚ö†Ô∏è Blockchain stats disabled, returning null');
    return null;
  }
  
  try {
    // Try to fetch from the real Solana blockchain
    console.log('üìä Attempting to fetch real blockchain stats...');
    console.log(`üîó PDA: ${gameStatsPDA.toString()}`);
    
    const accountInfo = await connection.getAccountInfo(gameStatsPDA);
    console.log('üîç Account info:', accountInfo ? 'Found' : 'Not found');
    
    if (accountInfo && accountInfo.data) {
      console.log('üì¶ Account data length:', accountInfo.data.length);
      // Parse blockchain data
      const blockchainStats = parseBlockchainData(accountInfo.data);
      console.log('üîç Parse result:', blockchainStats ? 'Success' : 'Failed');
      
      if (blockchainStats) {
        console.log('‚úÖ Successfully fetched from blockchain');
        
        // Add current user stats if username provided
        let currentUserStats = null;
        if (username) {
          const data = readDB();
          const user = data.users.find(u => u.username === username);
          const playerCounts = {};
          data.grid.forEach(block => {
            if (block.dugBy) {
              playerCounts[block.dugBy] = (playerCounts[block.dugBy] || 0) + 1;
            }
          });
          const userBlockCount = playerCounts[username] || 0;
          
          // Calculate remaining mining rights for today
          const today = new Date().toISOString().slice(0, 10);
          let remainingMines = 12; // Default daily limit
          
          if (user && user.lastDigDate === today) {
            remainingMines = Math.max(0, 12 - (user.dailyDigCount || 0));
          }
          
          currentUserStats = {
            username,
            totalBlocks: userBlockCount,
            remainingMines,
            color: user ? user.color : "#888",
            thetEarned: user ? (user.sentTokens || 0) : 0
          };
        }
        
        return {
          ...blockchainStats,
          currentUser: currentUserStats,
          programId: STATS_PROGRAM_ID,
          gameStatsPDA: gameStatsPDA.toString(),
          source: "Solana Blockchain (Devnet)"
        };
      }
    }
    
    console.log('‚ö†Ô∏è Blockchain data not available, falling back to local calculation');
    
    // Fallback to local calculation
    const data = readDB();
    
    // 1. Total number of blocks in grid
    const totalBlocks = data.grid.length;
    
    // 2. Number of mined blocks in grid  
    const minedBlocks = data.grid.filter(b => b.dugBy).length;
    
    // 3. Top 3 users with most blocks
    const playerCounts = {};
    data.grid.forEach(block => {
      if (block.dugBy) {
        playerCounts[block.dugBy] = (playerCounts[block.dugBy] || 0) + 1;
      }
    });
    
    const topMiners = Object.entries(playerCounts)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([name, count]) => {
        // Find user's color
        const user = data.users.find(u => u.username === name);
        return {
          name,
          blockCount: count,
          color: user ? user.color : "#888"
        };
      });

    // Top 3 THET owners
    const topThetOwners = data.users
      .filter(user => user.sentTokens && user.sentTokens > 0)
      .sort((a, b) => (b.sentTokens || 0) - (a.sentTokens || 0))
      .slice(0, 3)
      .map(user => ({
        name: user.username,
        thetEarned: user.sentTokens || 0,
        color: user.color || "#888"
      }));
    
    // 4. Current user's information (if username provided)
    let currentUserStats = null;
    if (username) {
      const user = data.users.find(u => u.username === username);
      const userBlockCount = playerCounts[username] || 0;
      
      // Calculate remaining mining rights for today
      const today = new Date().toISOString().slice(0, 10);
      let remainingMines = 12; // Default daily limit
      
      if (user && user.lastDigDate === today) {
        remainingMines = Math.max(0, 12 - (user.dailyDigCount || 0));
      }
      
      currentUserStats = {
        username,
        totalBlocks: userBlockCount,
        remainingMines,
        color: user ? user.color : "#888",
        thetEarned: user ? (user.sentTokens || 0) : 0
      };
    }
    
    const detailedStats = {
      // Temel bilgiler
      totalBlocks,
      minedBlocks,
      emptyBlocks: totalBlocks - minedBlocks,
      
      // Top 3 miners and THET owners
      topMiners,
      topThetOwners,
      
      // Current user information
      currentUser: currentUserStats,
      
      // Blockchain bilgileri
      programId: STATS_PROGRAM_ID,
      gameStatsPDA: gameStatsPDA.toString(),
      
      // Legacy values (for compatibility)
      totalBlocksMined: minedBlocks,
      gridExpansions: Math.floor(totalBlocks / 100) - 1
    };
    
    console.log('‚úÖ Detailed blockchain stats:', detailedStats);
    return detailedStats;
  } catch (error) {
    console.error('Failed to fetch on-chain stats:', error);
    return null;
  }
}

app.use(cors());
app.use(express.json());

const DB_FILE = './db.json';

function readDB() {
  try {
    return JSON.parse(fs.readFileSync(DB_FILE, 'utf8'));
  } catch (error) {
    return { grid: [], users: [] };
  }
}

function writeDB(data) {
  fs.writeFileSync(DB_FILE, JSON.stringify(data, null, 2));
}

const GRIDB_FILE = './gridb.json';
function readGridB(totalBlocks) {
  try {
    const arr = JSON.parse(fs.readFileSync(GRIDB_FILE, 'utf8'));
    // If the file has fewer blocks, add the remaining as empty
    if (arr.length < totalBlocks) {
      for (let i = arr.length; i < totalBlocks; i++) {
        arr.push({ index: i, owner: null, color: null, visual: null, userBlockIndex: null });
      }
      fs.writeFileSync(GRIDB_FILE, JSON.stringify(arr, null, 2));
    }
    return arr;
  } catch (e) {
    // If the file does not exist or is corrupted, create from scratch
    const arr = Array.from({ length: readDB().grid.length }, (_, i) => ({ index: i, owner: null, color: null, visual: null, userBlockIndex: null }));
    fs.writeFileSync(GRIDB_FILE, JSON.stringify(arr, null, 2));
    return arr;
  }
}
function writeGridB(arr) {
  fs.writeFileSync(GRIDB_FILE, JSON.stringify(arr, null, 2));
}

app.get('/grid', (req, res) => {
  const data = readDB();
  res.json(data.grid);
});

app.patch('/grid/:index', async (req, res) => {
  const sessionToken = req.headers['x-session-token'];
  if (!sessionToken || !sessions[sessionToken]) {
    return res.status(401).json({ error: 'Unauthorized: Invalid or missing session token' });
  }
  const username = sessions[sessionToken].username;

  const index = parseInt(req.params.index);
  const { visual } = req.body;
  const data = readDB();
  const block = data.grid[index];
  if (!block) {
    return res.status(404).json({ error: 'Block not found' });
  }
  if (block.dugBy) {
    // If the block is already mined, reject the operation
    return res.status(409).json({ error: 'Block already mined' });
  }

  // --- DAILY MINING LIMIT ---
  const user = data.users.find(u => u.username === username);
  if (!user) {
    return res.status(401).json({ error: 'Unauthorized: User not found' });
  }
  const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
  if (user.lastDigDate !== today) {
    user.lastDigDate = today;
    user.dailyDigCount = 0;
    
    // --- CASTLE BONUS: Auto-mining for 10-defense blocks ---
    try {
      const gridb = readGridB(data.grid.length);
      const castleCount = gridb.filter(b => 
        b.owner === username && b.defense === 10
      ).length;
      
      // Auto-mine blocks equal to castle count
      for(let i = 0; i < castleCount; i++) {
        const emptyBlock = data.grid.find(b => !b.dugBy);
        if (emptyBlock) {
          emptyBlock.dugBy = username;
        }
      }
      
      if (castleCount > 0) {
        console.log(`üè∞ Castle bonus: ${username} auto-mined ${castleCount} blocks`);
      }
    } catch (error) {
      console.log('Castle bonus error:', error.message);
    }
    // --- END CASTLE BONUS ---
  }
  if (user.dailyDigCount === undefined) user.dailyDigCount = 0;
  if (user.dailyDigCount >= 12) {
    return res.status(429).json({ error: 'Daily mining limit reached' });
  }
  user.dailyDigCount++;
  // --- SONU ---

  block.dugBy = username;
  block.visual = visual || null;
  writeDB(data);

  // üîó UPDATE BLOCKCHAIN: Sync miner after new block mined
  console.log(`‚õèÔ∏è ${username} mined block ${blockIndex}, syncing to blockchain...`);
  
  // Calculate current user's block count
  const userBlockCount = data.grid.filter(b => b.dugBy === username).length;
  
  // Update this specific miner on blockchain (non-blocking)
  updateMinerOnBlockchain(username, user.color || '#888888', userBlockCount, data.grid.length)
    .then(success => {
      if (success) {
        console.log(`‚úÖ ${username} synced to blockchain: ${userBlockCount} blocks`);
      }
    })
    .catch(err => console.log(`‚ùå Blockchain miner sync failed: ${err.message}`));

  // Update on-chain stats (non-blocking)
  incrementBlocksMinedOnChain(1).catch(err => {
    console.log('On-chain stats update failed (continuing anyway):', err.message);
  });

  res.json({ success: true });
});

app.post('/expand', (req, res) => {
  const data = readDB();
  const currentLength = data.grid.length;
  const newBlocks = [];
  for (let i = 0; i < 100; i++) {
    newBlocks.push({ index: currentLength + i, dugBy: null, color: null, visual: null });
  }
  data.grid = data.grid.concat(newBlocks);
  writeDB(data);
  res.json({ added: 100, total: data.grid.length });
});

app.get('/top-miners', (req, res) => {
  const data = readDB();
  const counts = {};
  for (const block of data.grid) {
    if (block.dugBy) {
      const key = block.dugBy;
      if (!counts[key]) {
        // Find user and get their color
        const user = data.users.find(u => u.username === key);
        counts[key] = { count: 0, color: user ? user.color : "#888" };
      }
      counts[key].count++;
    }
  }
  const sorted = Object.entries(counts)
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 10)
    .map(([name, info]) => ({ name, count: info.count, color: info.color }));
  res.json(sorted);
});

// Initialize game stats on blockchain (demo version)
app.post('/stats/initialize', async (req, res) => {
  try {
    console.log('üöÄ Demo: Initializing game stats on blockchain...');
    
    if (!blockchainStatsEnabled) {
      return res.json({
        success: false,
        message: 'Blockchain stats not available',
        note: 'PDA generation failed during startup'
      });
    }
    
    // For demo purposes, simulate initialization
    console.log('üìç Game Stats PDA:', gameStatsPDA.toString());
    console.log('üîó Program ID:', STATS_PROGRAM_ID);
    
    const mockTx = `init_tx_${Date.now()}`;
    console.log('‚úÖ Mock initialization complete! Transaction:', mockTx);
    
    res.json({ 
      success: true, 
      message: 'Game stats demo initialized',
      transactionId: mockTx,
      programId: STATS_PROGRAM_ID,
      gameStatsPDA: gameStatsPDA.toString()
    });
  } catch (error) {
    console.error('Initialization error:', error);
    res.status(500).json({ 
      error: 'Failed to initialize game stats',
      details: error.message 
    });
  }
});

// Get on-chain stats
app.get('/stats/blockchain', async (req, res) => {
  try {
    const username = req.query.username; // Username parametresi al
    console.log('üåê API /stats/blockchain called with username:', username);
    const onChainStats = await getOnChainStats(username);
    console.log('üìä getOnChainStats result:', onChainStats ? 'Got data' : 'No data');
    if (onChainStats) {
      console.log('‚úÖ Returning blockchain data');
      res.json({
        success: true,
        stats: onChainStats,
        source: 'blockchain'
      });
    } else {
      console.log('‚ö†Ô∏è Falling back to local data');
      // Fallback to local stats if blockchain is unavailable
      const data = readDB();
      
      // Calculate detailed local stats
      const totalBlocks = data.grid.length;
      const minedBlocks = data.grid.filter(b => b.dugBy).length;
      
      // Top 3 users with most blocks
      const playerCounts = {};
      data.grid.forEach(block => {
        if (block.dugBy) {
          playerCounts[block.dugBy] = (playerCounts[block.dugBy] || 0) + 1;
        }
      });
      
      const topMiners = Object.entries(playerCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([name, count]) => {
          const user = data.users.find(u => u.username === name);
          return {
            name,
            blockCount: count,
            color: user ? user.color : "#888"
          };
        });

      // Top 3 THET owners
      const topThetOwners = data.users
        .filter(user => user.sentTokens && user.sentTokens > 0)
        .sort((a, b) => (b.sentTokens || 0) - (a.sentTokens || 0))
        .slice(0, 3)
        .map(user => ({
          name: user.username,
          thetEarned: user.sentTokens || 0,
          color: user.color || "#888"
        }));
      
      // Current user stats if username provided
      let currentUser = null;
      if (username) {
        const user = data.users.find(u => u.username === username);
        const userBlockCount = playerCounts[username] || 0;
        
        const today = new Date().toISOString().slice(0, 10);
        let remainingMines = 12;
        
        if (user && user.lastDigDate === today) {
          remainingMines = Math.max(0, 12 - (user.dailyDigCount || 0));
        }
        
        currentUser = {
          username,
          totalBlocks: userBlockCount,
          remainingMines,
          color: user ? user.color : "#888",
          thetEarned: user ? (user.sentTokens || 0) : 0
        };
      }
      
      const localStats = {
        totalBlocks,
        minedBlocks,
        emptyBlocks: totalBlocks - minedBlocks,
        topMiners,
        topThetOwners,
        currentUser,
        totalBlocksMined: minedBlocks,
        gridExpansions: Math.floor(totalBlocks / 100) - 1
      };
      res.json({
        success: true,
        stats: localStats,
        source: 'local_fallback'
      });
    }
  } catch (error) {
    console.error('Stats fetch error:', error);
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
});

app.post('/reset-tokens', async (req, res) => {
  const { username, walletAddress, blockCount } = req.body;
  if (!walletAddress || !blockCount || blockCount <= 0) {
    return res.status(400).json({ error: 'Invalid wallet address or block count' });
  }
  const data = readDB();
  const user = data.users.find(user => user.username === username);
  if (!user) {
    return res.status(400).json({ error: 'User not found' });
  }
  try {
    const receiverPubkey = new PublicKey(walletAddress);
    const senderTokenAccount = await getOrCreateAssociatedTokenAccount(connection, senderKeypair, THE_TOKEN_MINT, senderKeypair.publicKey);
    const receiverTokenAccount = await getOrCreateAssociatedTokenAccount(connection, senderKeypair, THE_TOKEN_MINT, receiverPubkey);
    const transaction = new Transaction().add(
      createTransferInstruction(
        senderTokenAccount.address,
        receiverTokenAccount.address,
        senderKeypair.publicKey,
        blockCount * 1000000000
      )
    );
    const signature = await connection.sendTransaction(transaction, [senderKeypair]);
    await connection.confirmTransaction(signature, 'confirmed');
    
    // Reset the blocks mined by the user from BOTH grids
    data.grid.forEach(block => {
      if (block.dugBy === username) {
        block.dugBy = null;
        block.color = null;
        block.visual = null;
      }
    });

    // ALSO reset blocks from warzone (gridb)
    const gridBData = readGridB(data.grid.length);
    gridBData.forEach(block => {
      if (block.owner === username) {
        block.owner = null;
        block.color = null;
        block.visual = null;
        block.userBlockIndex = null;
        block.defense = 0;
      }
    });
    writeGridB(gridBData);

    user.sentTokens = (user.sentTokens || 0) + blockCount;
    writeDB(data);
    
    // üîó UPDATE BLOCKCHAIN: Sync THET earnings after reset
    console.log(`üîÑ Syncing ${username} THET to blockchain after reset...`);
    updateThetOnBlockchain(username, user.color || '#888888', user.sentTokens)
      .then(success => {
        if (success) {
          console.log(`‚úÖ ${username} THET synced to blockchain: ${user.sentTokens} THET`);
        }
      })
      .catch(err => console.log(`‚ùå Blockchain THET sync failed: ${err.message}`));
    
    // Also sync all miners since grid changed
    syncAllMinersToBlockchain(data)
      .then(success => {
        if (success) {
          console.log(`‚úÖ All miners synced to blockchain after ${username} reset`);
        }
      })
      .catch(err => console.log(`‚ùå Blockchain miners sync failed: ${err.message}`));
    
    res.json({ success: true, sentTokens: user.sentTokens, rewardSignature: signature });
  } catch (error) {
    console.error('Reward transfer error:', error);
    res.status(400).json({ error: error.message });
  }
});

app.post('/transfer-token', async (req, res) => {
  const { receiverAddress, amount } = req.body;
  try {
    const receiverPubkey = new PublicKey(receiverAddress);
    const senderTokenAccount = await getOrCreateAssociatedTokenAccount(connection, senderKeypair, THE_TOKEN_MINT, senderKeypair.publicKey);
    const receiverTokenAccount = await getOrCreateAssociatedTokenAccount(connection, senderKeypair, THE_TOKEN_MINT, receiverPubkey);
    const transaction = new Transaction().add(
      createTransferInstruction(
        senderTokenAccount.address,
        receiverTokenAccount.address,
        senderKeypair.publicKey,
        Math.floor(amount * 1000000000)
      )
    );
    const signature = await connection.sendTransaction(transaction, [senderKeypair]);
    await connection.confirmTransaction(signature, 'confirmed');
    res.json({ success: true, signature });
  } catch (error) {
    console.error('Transfer error:', error);
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/update-username', async (req, res) => {
  const { currentUsername, newUsername } = req.body;
  if (!currentUsername || !newUsername) {
    return res.status(400).json({ error: 'Current and new usernames are required' });
  }
  if (newUsername.length < 3) {
    return res.status(400).json({ error: 'New username must be at least 3 characters long' });
  }
  try {
    const data = readDB();
    const userIndex = data.users.findIndex(user => user.username === currentUsername);
    if (userIndex === -1) {
      return res.status(404).json({ error: 'User not found' });
    }
    const usernameExists = data.users.some(user => user.username === newUsername);
    if (usernameExists) {
      return res.status(400).json({ error: 'This username is already taken' });
    }
    data.users[userIndex].username = newUsername;
    data.grid = data.grid.map(block => {
      if (block.dugBy === currentUsername) {
        return { ...block, dugBy: newUsername };
      }
      return block;
    });
    writeDB(data);
    res.json({ success: true, newUsername });
  } catch (error) {
    console.error('Username update error:', error);
    res.status(500).json({ error: 'Username update failed' });
  }
});

app.get('/auth/user', (req, res) => {
  const username = req.query.username;
  if (!username) {
    return res.status(400).json({ error: 'Username is required' });
  }
  const data = readDB();
  const user = data.users.find(u => u.username === username);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  res.json(user);
});

app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  const data = readDB();
  const user = data.users.find(user => user.email === email);

  if (!user) {
    return res.status(400).json({ error: 'User not found' });
  }

  if (!user.isVerified) {
    return res.status(400).json({ error: 'Email not verified' });
  }

  const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
  if (!isPasswordValid) {
    return res.status(400).json({ error: 'Invalid password' });
  }

  // Session token generate and store
  const sessionToken = generateSessionToken();
  sessions[sessionToken] = { username: user.username, createdAt: Date.now() };

  res.json({ success: true, username: user.username, color: user.color, walletAddress: user.walletAddress, sentTokens: user.sentTokens, sessionToken });
});

// GET /gridb: Return the current state of GridB
app.get('/gridb', (req, res) => {
  const totalBlocks = readDB().grid.length;
  const gridb = readGridB(totalBlocks);
  res.json(gridb);
});

// PATCH /gridb/:index: User adds the next of their own blocks
app.patch('/gridb/:index', (req, res) => {
  try {
    const sessionToken = req.headers['x-session-token'];
    if (!sessionToken || !sessions[sessionToken]) {
      return res.status(401).json({ error: 'Unauthorized: Invalid or missing session token' });
    }
    const username = sessions[sessionToken].username;
    const blockIndex = parseInt(req.params.index);
    const db = readDB();
    const totalBlocks = db.grid.length;
    let gridb = readGridB(totalBlocks);
    if (blockIndex < 0 || blockIndex >= totalBlocks) {
      return res.status(400).json({ error: 'Invalid block index' });
    }
    if (!gridb[blockIndex]) {
      return res.status(400).json({ error: 'Block not found' });
    }

    // User stock control (mined blocks count - total defense used in gridb)
    const userBlocks = db.grid.filter(b => b.dugBy === username);
    const userBlocksInGridB = gridb.filter(b => b.owner === username);
    const totalDefenseUsed = userBlocksInGridB.reduce((sum, b) => sum + (b.defense || 1), 0);
    const userStock = userBlocks.length - totalDefenseUsed;

    // If user has no blocks in gridb and no empty blocks, they can place first block anywhere
    const userHasNoBlocksInGridB = userBlocksInGridB.length === 0;
    const emptyBlocks = gridb.filter(b => !b.owner);
    const isFirstPlacement = userHasNoBlocksInGridB && emptyBlocks.length === 0;

    const block = gridb[blockIndex];
    // Clicking empty block or claiming ownerless block
    if (!block.owner) {
      if (userStock <= 0 && !isFirstPlacement) {
        return res.status(400).json({ error: 'No stock left to place a block' });
      }
      
      // No additional cost for claiming - already paid during attack
      
      gridb[blockIndex] = { index: blockIndex, owner: username, defense: 1 };
      writeGridB(gridb);
      return res.json(gridb);
    }

    // Clicking own block (increase defense)
    if (block.owner === username) {
      // Stock required to increase defense too
      if (userStock <= 0) {
        return res.status(400).json({ error: 'No stock left to increase defense' });
      }
      
      // Defense increase is just redistribution - no block loss from GridA
      gridb[blockIndex].defense = (typeof gridb[blockIndex].defense === 'number' ? gridb[blockIndex].defense : 1) + 1;
      writeGridB(gridb);
      return res.json(gridb);
    }

    // Clicking someone else's block
    // Neighbor check: user must have at least one neighboring block
    // --- 2D grid neighbor logic ---
    // Must be calculated same way as frontend
    const aspectRatio = 16 / 9;
    let cols = Math.ceil(Math.sqrt(totalBlocks * aspectRatio));
    let rows = Math.ceil(totalBlocks / cols);
    while (cols / rows > aspectRatio + 0.01) {
      cols--;
      rows = Math.ceil(totalBlocks / cols);
    }
    while (cols / rows < aspectRatio - 0.01) {
      cols++;
      rows = Math.ceil(totalBlocks / cols);
    }
    const getNeighbors = (idx) => {
      const neighbors = [];
      const row = Math.floor(idx / cols);
      const col = idx % cols;
              if (col > 0) neighbors.push(idx - 1); // left
      if (col < cols - 1) neighbors.push(idx + 1); // right
      if (row > 0) neighbors.push(idx - cols); // top
              if (row < rows - 1 && idx + cols < totalBlocks) neighbors.push(idx + cols); // bottom
      return neighbors;
    };
    const neighbors = getNeighbors(blockIndex);
    const hasNeighbor = neighbors.some(n => gridb[n] && gridb[n].owner === username);
    if (!hasNeighbor && !isFirstPlacement) {
      return res.status(403).json({ error: 'You must have a neighboring block to attack' });
    }
    
    // ‚ö° CASTLE PROTECTION: Castle attacks forbidden on first placement
    if (isFirstPlacement && currentDefense === 10) {
      return res.status(403).json({ error: 'Cannot attack castles on first placement. Attack a neighboring block first.' });
    }
    // Attack mechanics
    const currentDefense = typeof gridb[blockIndex].defense === 'number' ? gridb[blockIndex].defense : 1;
    const prevOwner = gridb[blockIndex].owner;
    
    // Each attack costs attacker 1 block
          const attackerBlocks = db.grid
        .map((b, i) => ({ ...b, _idx: i }))
        .filter(b => b.dugBy === username)
        .sort((a, b) => b.index - a.index); // Start from highest index
    
    if (attackerBlocks.length > 0) {
      const toDelete = attackerBlocks[0];
      db.grid[toDelete._idx].dugBy = null;
      if ('visual' in db.grid[toDelete._idx]) db.grid[toDelete._idx].visual = null;
    }
    
    // Each attack costs defender 1 block too
    if (prevOwner && prevOwner !== username) {
      const defenderBlocks = db.grid
        .map((b, i) => ({ ...b, _idx: i }))
        .filter(b => b.dugBy === prevOwner)
        .sort((a, b) => b.index - a.index); // Start from highest index
      
      if (defenderBlocks.length > 0) {
        const toDelete = defenderBlocks[0];
        db.grid[toDelete._idx].dugBy = null;
        if ('visual' in db.grid[toDelete._idx]) db.grid[toDelete._idx].visual = null;
      }
    }
    
    writeDB(db); // Save attack cost
    
    // Defense azalt
    gridb[blockIndex].defense = currentDefense - 1;
    
    if (gridb[blockIndex].defense <= 0) {
      // Block becomes ownerless
      gridb[blockIndex].owner = null;
      gridb[blockIndex].defense = 0;
    }
    writeGridB(gridb);
    res.json(gridb);
  } catch (e) {
    console.error('PATCH /gridb/:index error:', e);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// DELETE /gridb/:index: User removes their own block
app.delete('/gridb/:index', (req, res) => {
  const sessionToken = req.headers['x-session-token'];
  if (!sessionToken || !sessions[sessionToken]) {
    return res.status(401).json({ error: 'Unauthorized: Invalid or missing session token' });
  }
  const username = sessions[sessionToken].username;
  const blockIndex = parseInt(req.params.index);
  const totalBlocks = readDB().grid.length;
  let gridb = readGridB(totalBlocks);
  if (blockIndex < 0 || blockIndex >= totalBlocks) {
    return res.status(400).json({ error: 'Invalid block index' });
  }
  if (!gridb[blockIndex].owner || gridb[blockIndex].owner !== username) {
    return res.status(403).json({ error: 'You can only remove your own block' });
  }
  gridb[blockIndex] = { index: blockIndex, owner: null, color: null, visual: null, userBlockIndex: null };
  writeGridB(gridb);
  res.json(gridb);
});

    // POST /update-block-color: User updates their block's color
// This endpoint removed

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Custom server running at http://0.0.0.0:${PORT}`);
});
